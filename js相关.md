# js相关
1. 事件委托
    + 原理
        不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点
        比如给ul注册了点击事件，然后利用对象的target来找到当前被点击的li，因为被点击的li包含在ul里面，时间会冒泡到ul上，ul有注册时间，就会触发下面的事件监听器
        ul.addEventListener('click', function(){},false)
        事件监听器的第三个选项不填则默认为false冒泡
    + 作用
        我们只操作了一次DOM，提高了程序的性能
        子元素的事件不必再单独分配注册一个事件，只需要给其父元素安排事件即可
2. 原型和原型链
    + 原型 被用于复制现有实例来生成新实例的函数
        js中每一个函数都有一个prototype属性，这个属性指向函数的原型对象，每一个由原型对象派生的子对象，都有相同的属性。子对象就叫构造函数，从实例原型中获取相同的属性。
    + 构造函数constructor 用new来调用，就是为了创建一个自定义类
        每个原型都有一个construtor属性，指向该关联的构造函数。        
    + 实例 是类在实例化之后一个一个具体的对象
    + 原型链 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。
    + _Proto_ 它是每一个子对象（除null外）都会有的一个属性，指向该对象的原型。
        function Person(){}
        var person = new Person();
        console.log( person.__proto__ === Person.prototype ); // true
        此属性可以访问原型，但并不存在于Person.prototype中，来自于Object.prototype，类似getter/setter，既使用obj._proto_时，可以理解为返回Object.getPrototypeOf(obj)
        Person(构造函数)-------prototype-------》Person.prototype(实例原型)
                |                                         ∧
                ∨                                         |
              person----------------------_proto_----------
3. null和undefined的区别
    + null是一个表示“无”的对象(空对象指针)，转为数值为0；
    + undefined是一个表示“无”的原始值，转为数值时为NaN
    + null表示“没有对象”，既该处不应该有值。典型的用法是：
        作为函数的参数，表示该函数的参数不是对象。
        作为对象原型链的终点
    + undefined表示“缺少值”，就是此处应该有一个值，但是还没有被定义。典型用法是：
        变量被声明了，但没有赋值时，就等于undefined
        调用函数时，应该提供的参数没有提供，该参数等于undefined
        对象没有赋值的属性，该属性的值为undefined
        函数没有返回值时，默认返回undefined
4. 如何实现继承
    对于JavaScript来说，继承有两个要点： 1. 复用父构造函数中的代码 2. 复用父原型中的代码第一种实现复用父构造函数中的代码，我们可以考虑调用父构造函数并将this绑定到子构造函数。
    + 复用父原型中的代码，我们只需要改变原型链即可。将子构造函数的原型对象的proto属性指向父构造函数的原型对象
    + 使用new操作符来替代直接使用proto属性来改变原型链。
    + 使用一个空构造函数来作为中介函数，这样就不会将构造函数中的属性混到prototype中
5. Promise和async/await的区别和使用
    + 函数前面多了个async关键字。await关键字只能用在async定义的函数内。async函数会隐式地返回一个promise，该promise的resolve值就是函数return的值
    + async和awite是配对使用的，await存在于async内部，否则会报错
    + await表示在这里等待一个promise返回，再接下来执行。
    + await后面跟着的应该是一个promise对象。
6. 什么是懒加载和预加载
    + 懒加载也叫延迟加载，延迟加载网络资源或符合某些条件时才加载资源，常见的就是图片延迟加载
    + 懒加载的意义 懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。
    + 懒加载实现方式 
        - 纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟。
        - 条件加载，符合某些条件，或触发了某些事件才开始异步下载
        - 可视区加载 仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离便开始加载，这样能保证用户拉下时正好能看到图片
    + 预加载 提前加载图片，当用户需要查看时可以直接从本地缓存中渲染。
7. 如何获取对象的原型
    + Object.getPrototypeof();
    + obj.constructor.prototype;
    + obj.__proto__
    + 第一种最靠谱
8. new操作符实现的原理   __TODO__
9. call apply bind
    + 都是改变this指向的方法
    + call 非严格模式下，如果不传参数或者第一个参数是null或者undefined，this都指向window。严格模式下，第一个参数是谁，this就指向谁，包括null和undefined，如果不传参数this就是undefined
    + apply和call基本一致，唯一区别在于传参方式不同，apply把需要传递给fn的参数放到一个数组（或者类数组）中传递过去，call是把所有参数依次写上
    + bind语法和call一模一样，区别在于立即执行还是等待执行
    + apply 
        - 接收两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入
        - 改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次
    + call 
        - call方法的第一个参数也是this的指向，后面传入的是一个参数列表
        - 跟apply一样，改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次
    + bind
        - bind方法和call很相似，第一参数也是this的指向，后面传入的也是一个参数列表（但是这个参数列表可以分多次传入）
        - 改变this指向后不会立即执行，而是返回一个永久改变this指向的函数
    + 区别
        - 三者都可以改变函数的this对象指向
        - 三者第一个参数都是this要指向的对象，如果没有这个参数或参数为undefined或null，则默认指向全局window
        - 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入
        - bind是返回绑定this之后的函数，apply、call则是立即执行
10. 闭包以及使用场景
    + 什么是闭包：闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰，使得私有变量不被JavaScript垃圾回收机制强制回收，直观的讲是函数里面套函数。
    + 闭包的优点：一个函数可以访问另一个函数的变量，可以保护私有变量不被全局变量污染，在一个不熟悉的网页中嵌入功能使用闭包是很好的选择
    + 闭包的缺点：过多的使用闭包会造成内存占用过多的问题，滥用闭包会造成内存泄露即内存不被释放，我们知道函数一执行完里面的变量就会立即销毁。

11. es6常见的新特性   __TODO__
12. let const var的区别   __TODO__
13. promise的原理以及什么是回调地狱（为什么会产生回调地狱）   __TODO__
14. promise.all()的原理   __TODO__ 
15. = == === 
    + = 是赋值
    + == 和 != 比较若类型不同，先尝试装换类型，再作值比较，最后返回值比较的结果
    + === 和 !== 只有在相同的类型下才会比较值
16. 事件循环
    + 机制
        - JS引擎指向代码是从上往下执行的
        - 如果某一行报错，则停止执行下面的代码
        - 先执行同步代码再执行异步代码
    + 执行过程
        - 同步代码： 调用栈执行后直接出栈
        - 异步代码： 放到Web Api中，等待合适的时机放入回调队列，等到栈时空事件循环（EventLoop）开始工作，进行轮询。
        - 微任务比宏任务执行时机要早。 微任务在DOM渲染前触发，宏任务在DOM渲染后触发
            宏任务： 由浏览器规定的 1. setTimeout 2. setInterval 3. Ajax 4. DOM事件
            微任务： 由ES6语法规定的 1. Promise 2. async 3. await
        - 整体过程
            1. 先清空调用栈（call stack）中的同步代码
            2. 之行微任务队列中的微任务
            3. 尝试DOM渲染
            4. 触发事件循环（Event Loop）反复询问回调队列中是否有要执行的语句，有则放入调用栈继续执行。
17. JS的数据类型
    + 原始类型： null、undefined、number、string、boolean、Symbol、BigInt
    + 引用类型： 对象
18. 创建一个undefined
    + 不能使用 var a = undefined; 函数内可以给undefined赋值
    + 使用 var a = void 0;


